# TIL

##### 자연어 처리(nlp)



## 1. 한국어의 토큰화의 어려움

영어는 띄어쓰기 토큰화가 잘 이뤄지지만 한국어는 어절단위로 띄어쓰기를 하는데, 어절 토큰화는 단어 토큰화와 다르기 때문에 지양되는 토큰화 방법이다.

#### 한국어는 교착어이다.

한국어를 읽을 때, `he is`와 같은 문장은 `그는, 그를, 그에게, 그와`등으로 읽어질 수 있는데, 이런 조사, 어미를 붙여 만드는 언어를 교착어라고 한다. 그리고 이런 토큰화는 서로 다른 뜻을 야기할 수 있으므로 조사, 어미를 떼어내고 토큰화를 해야할 필요가 있다. 이런 이유로 한국어 토큰화에서는 형태소의 개념을 반드시 이해해야 한다. 형태소란 뜻을 가진 가장 작은 단위의 말을 말하는데, 이는 두 가지로 분류된다.

- 자립 형태소 : 접사, 어미, 조사와 상관없이 자립하여 사용할 수 있는 형태소이며 그 자체로 단어가 된다.
- 의존 형태소 : 다른 형태소와 결합하여 사용하는 형태소. 접사, 어미, 조사, 어간을 말한다.

예를 들어 다음과 같은 문장에서,

- 에디가 딥러닝책을 읽었다.

이를 형태소로 분리하면,

자립 형태소 : 에디, 딥러닝책

의존형태소 : 가, 을, 읽, 었, 다

우리는 이를 통해 어절 토큰화가 아닌 형태소 토큰화를 해야함을 알 수 있다.

#### 한국어는 띄어쓰기가 잘 지켜지지 않는다.

영어는 띄어쓰기를 제대로 하지 않으면 이해되지 않는 경우가 있는데, 한국어는 띄어쓰기를 안 해도 알아볼 수 있다는 장(점이자 단)점이 있다. 결국 많은 코퍼스들 사이에서 띄어쓰기가 무시되어 자연어 처리가 어려운 경향이 있음을 알 수 있다.



## 2. 품사 태깅(Part-of-speech tagging)

영어와 마찬가지로 한국어는 동음이의어가 존재하고, 이 뜻이 서로 다른 경우가 많이 있어 이를 분별하기 위한 방법으로 품사를 분석하여 어떤 의미로 쓰였는지를 확인하는 방법이 있다.



## 3. NLTK와 KoNLPy를 이용한 영어, 한국어 토큰화

NLTK에서는 영어 코퍼스에 대한 품사 태깅 기능을 지원한다. 어떻게 품사를 명명하는지의 기준은 `NLTK : Penn Treebank POS Tags`이다.

```python
from nltk.tokenize import word_tokenize
text = 'I am actively looking for Ph.D. students. and you are a Ph.D. student.'
print(word_tokenize(text))

#['I', 'am', 'actively', 'looking', 'for', 'Ph.D.', 'students', '.', 'and', 'you', 'are', 'a', 'Ph.D.', 'student', '.']
```

```python
from nltk.tag import pos_tag
x = word_tokenize(text)
pos_tag(x)
#[('I', 'PRP'), ('am', 'VBP'), ('actively', 'RB'), ('looking', 'VBG'), ('for', 'IN'), ('Ph.D.','NNP'), ('students', 'NNS'), ('.', '.'), ('and', 'CC'), ('you', 'PRP'), ('are', 'VBP'), ('a', 'DT'), ('Ph.D.', 'NNP'), ('student', 'NN'), ('.', '.')]
```

여기서, PRP는 인칭 대명사, VBP는 동사, RB는 부사, VBG는 현재부사, IN은 전치사, NNP는 고유 명사, NNS는 복수형 명사, CC는 접속사, DT는 관사를 의미한다.

한국어 자연어 처리에서는 KoNLPy(코엔엘파이)라는 패키지를 사용할 수 있다. 이를 통해 사용할 수 있는 형태소 분석기로는 Okt(Open Korea Text), 메캅, 코모란, 한나눔, 꼬꼬마가 있다. 한국어 NLP에서 형태소 분석기는 단어 토큰화가 아닌 형태소 토큰화를 한다는 의미를 가진다. 이 중에서 Okt는 twitter에서 이름이 바뀐 것이다.

- Okt tokenizer

```python
from konlpy.tag import Okt
okt = Okt()
print(okt.morphs("열심히 코딩한 당신, 연휴에는 여행을 가봐요")) # morphs : 형태소
#['열심히', '코딩', '한', '당신', ',', '연휴', '에는', '여행', '을', '가봐요']
print(okt.pos("열심히 코딩한 당신, 연휴에는 여행을 가봐요")) # pos : 품사 태깅
#[('열심히', 'Adverb'), ('코딩', 'Noun'), ('한', 'Josa'), ('당신', 'Noun'), (',', 'Punctuation'), ('연휴', 'Noun'), ('에는', 'Josa'), ('여행', 'Noun'), ('을', 'Josa'), ('가봐요', 'Verb')]
print(okt.nouns("열심히 코딩한 당신, 연휴에는 여행을 가봐요")) # nouns : 명사 추출
#['코딩', '당신', '연휴', '여행']
```

- 꼬꼬마 tokenizer

```python
from konlpy.tag import Kkma
kkma = Kkma()
print(kkma.morphs("열심히 코딩한 당신, 연휴에는 여행을 가봐요")) # morphs : 형태소
#['열심히', '코딩', '하', 'ㄴ', '당신', ',', '연휴', '에', '는', '여행', '을', '가보', '아요']
print(kkma.pos("열심히 코딩한 당신, 연휴에는 여행을 가봐요"))  # pos : 품사 태깅
#[('열심히', 'MAG'), ('코딩', 'NNG'), ('하', 'XSV'), ('ㄴ', 'ETD'), ('당신', 'NP'), (',', 'SP'), ('연휴', 'NNG'), ('에', 'JKM'), ('는', 'JX'), ('여행', 'NNG'), ('을', 'JKO'), ('가보', 'VV'), ('아요', 'EFN')]
print(kkma.nouns("열심히 코딩한 당신, 연휴에는 여행을 가봐요"))
#['코딩', '당신', '연휴', '여행']
```

이처럼 형태소 분석은 사용하는 분석기에 따라 성능과 결과가 다르다. 그래서 형태소 분석기의 선택은 사용하고자 하는 필요 용도에 맞게 어떤 분석기가 가장 적절한지를 판단하고 사용하면 된다.
